'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; // 第三方

// 自定义


var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _glob = require('glob');

var _glob2 = _interopRequireDefault(_glob);

var _webpack = require('webpack');

var _webpack2 = _interopRequireDefault(_webpack);

var _webpackMerge = require('webpack-merge');

var _webpackMerge2 = _interopRequireDefault(_webpackMerge);

var _vuxLoader = require('vux-loader');

var _vuxLoader2 = _interopRequireDefault(_vuxLoader);

var _autoprefixer = require('autoprefixer');

var _autoprefixer2 = _interopRequireDefault(_autoprefixer);

var _webpackNodeExternals = require('webpack-node-externals');

var _webpackNodeExternals2 = _interopRequireDefault(_webpackNodeExternals);

var _serverPlugin = require('vue-server-renderer/server-plugin');

var _serverPlugin2 = _interopRequireDefault(_serverPlugin);

var _config = require('./config.js');

var _config2 = _interopRequireDefault(_config);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// 字符替换loader，替换全局环境变量
var replaceLoader = {
  loader: _path2.default.resolve(__dirname + '/loader/replace-loader.js'),
  options: {
    replacer: function () {
      var replacer = _extends({}, _config2.default.replacer);
      delete replacer.regex;
      return replacer;
    }()
  }
};

var mergeObj = (0, _webpackMerge2.default)(require('./webpack.base.config.js').default, {
  // 将 entry 指向应用程序的 server entry 文件
  entry: function () {
    var entry = {};

    // 设置编译入口
    _glob2.default.sync(__dirname + '/../../../' + _config2.default.path.js).forEach(function (filePath) {
      // 根据js路径获取信息
      var result = /src[/](page[/](.*)[/]js[/](.*))[.]js/.exec(filePath);

      // js文件名
      var jsDirName = result[2];
      // js父级目录名
      var jsFileName = result[3];

      // 只编译文件名和目录名相同的js
      if (jsDirName + '-server' === jsFileName) {
        // 打包入口
        var entryName = result[1];
        // 入口文件路径
        var entryPath = './src/' + entryName + '.js';
        // 设置入口
        entry[entryName] = entryPath;
      }
    });

    // 检测入口数量，打印出入口
    console.log('webpack入口:');
    var entryCount = 0;
    for (var i in entry) {
      console.log(i + ': ' + entry[i]);
      entryCount++;
    }
    if (entryCount <= 0) {
      throw Error('webpack入口js数量为0，请检查developer.config.js配置目录名是否正确。');
    }

    console.log('\u6B63\u5728\u7F16\u8BD1js...');

    return entry;
  }(),

  // 这允许 webpack 以 Node 适用方式(Node-appropriate fashion)处理动态导入(dynamic import)，
  // 并且还会在编译 Vue 组件时，
  // 告知 `vue-loader` 输送面向服务器代码(server-oriented code)。
  target: 'node',

  // https://webpack.js.org/configuration/externals/#function
  // https://github.com/liady/webpack-node-externals
  // 外置化应用程序依赖模块。可以使服务器构建速度更快，
  // 并生成较小的 bundle 文件。
  // 外置的模块将不会被预处理
  externals: (0, _webpackNodeExternals2.default)({
    // 不要外置化 webpack 需要处理的依赖模块。
    // 你可以在、这里添加更多的文件类型。例如，未处理 *.vue 原始文件，
    // 你还应该将修改 `global`（例如 polyfill）的依赖模块列入白名单
    whitelist: [/^dvd-/]
  }),

  // 对 bundle renderer 提供 source map 支持
  devtool: 'source-map',

  // 此处告知 server bundle 使用 Node 风格导出模块(Node-style exports)
  output: {
    libraryTarget: 'commonjs2',
    filename: '[name].js'
  },

  // 这是将服务器的整个输出
  // 构建为单个 JSON 文件的插件。
  // 默认文件名为 `vue-ssr-server-bundle.json`
  plugins: [new _serverPlugin2.default()]
});

exports.default = mergeObj;